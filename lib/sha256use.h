////////////////////////////////////////////////////////////////////
//PRODUZ O ENDERECO BTC
//NAO VERIFICA NUMEROS FORA DO MOD P, PARA OTIMIZACAO
//
// ESTA VERSAO DE WALLETA TEM UMA SERIE DE TESTES DE
// OPERACOES COM PONTEIROS, VISANDO A OTIMIZACAO COM
// RELACAO A VELOCIADE DE EXECUCAO DO CODIGO.
//
////////////////////////////////////////////////////////////////////

class SHA256Use
{	
	public:

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	unsigned long W[64], W2[64], W22[64], W3[64], W4[64], W5[64];
	SHA256 sha256H;
	//Ripemd160 rmd160;
	//Esta funcao executa o pading dos arrays W e W22
	//Deve ser chamada apenas uma vez ao longo de toda
	//a execucao do codigo;
	void padFixSHA256()
	{
		//PADING PLUS LENGTH DA STRING UNICA DE 512 BITs 
							W[9] = 0x00000000; W[10] = 0x00000000; W[11] = 0x00000000;
		W[12] = 0x00000000; W[13] = 0x00000000; W[14] = 0x00000000; W[15] = 0x00000100;//W[15] = 0x00000108;

		/*
		//PADING PLUS LENGTH DA STRING DE 1024 BITs 
					W22[1] = 0x00000000; W22[2] = 0x00000000; W22[3] = 0x00000000;
		W22[4] = 0x00000000; W22[5] = 0x00000000; W22[6] = 0x00000000; W22[7] = 0x00000000;
		W22[8] = 0x00000000; W22[9] = 0x00000000; W22[10] = 0x00000000; W22[11] = 0x00000000;
		W22[12] = 0x00000000; W22[13] = 0x00000000; W22[14] = 0x00000000; W22[15] = 0x00000208;

		//PADING PLUS LENGTH DA STRING PARA (VERSAO + RIPEMD160)
							W3[9] = 0x00000000; W3[10] = 0x00000000; W3[11] = 0x00000000;
		W3[12] = 0x00000000; W3[13] = 0x00000000; W3[14] = 0x00000000; W3[15] = 0x000000A8;
							W4[9] = 0x00000000; W4[10] = 0x00000000; W4[11] = 0x00000000;
		W4[12] = 0x00000000; W4[13] = 0x00000000; W4[14] = 0x00000000; W4[15] = 0x000000A8;


				W5[8] = 0x80000000; W5[9] = 0x00000000; W5[10] = 0x00000000; W5[11] = 0x00000000;
		W5[12] = 0x00000000; W5[13] = 0x00000000; W5[14] = 0x00000000; W5[15] = 0x00000100;

		*/


					//1010 1000 = A8 
					//(128 + 32) = 160
	}
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////


	cpp_int sha256BInt (cpp_int g)
	{
		//cpp_int *g;
		//unsigned char chA[64], cSHA[33], cSHA2[65], cSHAZH[33], *xzh;
		//unsigned long W[64], W2[64], W22[64], Hi[8], Hi2[8];
		unsigned long Hi[8];
		cpp_int tA, ichA;


		////////////////////////////////////////////////////////////////////////////////////////
		// EMPACOTAMENTO DOS DADOS PARA A SHA256ZH
		// PARA STRINGS DE (256 + 8) BITS
		////////////////////////////////////////////////////////////////////////////////////////
		ichA = g;
		//ichA2 = g[1];

		////////////////////////////////////////////////////////////////////////////////////////
		// ULTIMO BYTE DA STRING FICA EM UM W ISOLADO
		// POIS O PRIMEIRO BYTE NO W[0] EH PREENCHIDO
		// PELO BYTE DE VERSAO
		////////////////////////////////////////////////////////////////////////////////////////
		//W[8] = W2[8] = ( 0x01000000 * (unsigned long)(ichA & 255) ) + 0x00800000;
		W[8] = 0x80000000;
		//W22[0] = ( 0x01000000 * (unsigned long)(ichA2 & 255) ) + 0x00800000;

		//ichA = ichA/256;
		//ichA2 = ichA2/256;
		////////////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////////////////////////////
		// ESTE FOR PODE SER ELIMINADO PARA AUMENTAR A VOLOCIDADE DE EXECUCAO
		////////////////////////////////////////////////////////////////////////////////////////
		for (int i = 7; i>= 0; i--)
		{
			//W[i] = W2[i] = (unsigned long)(ichA & 0xFFFFFFFF);
			W[i] = (unsigned long)(ichA & 0xFFFFFFFF);
			//W2[i+8] = (unsigned long)(ichA2 & 0xFFFFFFFF);
			ichA = ichA/(0x100000000);
			//ichA2 = ichA2/(0x100000000);
		}

		////////////////////////////////////////////////////////////////////////////////////////
		// DEVEMOS TIRAR 0x00800000 de W2[8] QUE FOI ACRESCENTADO ACIMA
		////////////////////////////////////////////////////////////////////////////////////////
		//W2[8] = (W2[8] - 0x00800000) + (unsigned long)(ichA2 & 0xFFFFFF);

		////////////////////////////////////////////////////////////////////////////////////////
		// ACRESCIMO DO BYTE DE VERSAO COM OS 6 ULTIMOS BYTES
		////////////////////////////////////////////////////////////////////////////////////////
		//if (g[1] & 1) W[0] = (0x03000000) + (unsigned long)(ichA & 0xFFFFFF);
		//else W[0] = (0x02000000) + (unsigned long)(ichA & 0xFFFFFF);
		//W2[0] = (0x04000000) + (unsigned long)(ichA & 0xFFFFFF);

	////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////
	//HASH SHA256 DA CHAVE PUBLICA COMPRIMIDA
	////////////////////////////////////////////////////////////////////

		//unsigned char SHA256outB[32], SHA256outB2[32];

		//HASH SHA256ZH
		//printf("RESULTADO DO NOVO SHA256 CHAVE COMPRIMIDA: \n");
		sha256H.sha256G (W, sha256H.H0, Hi);
		//printf("%x %x %x %x %x %x %x %x \n", Hi[0], Hi[1], Hi[2], Hi[3], Hi[4], Hi[5], Hi[6], Hi[7]);

		//printf("RESULTADO DO NOVO SHA256 CHAVE NAO COMPRIMIDA: \n");
		//sha256H.sha256G (W2, sha256H.H0, Hi2);
		//sha256H.sha256G (W22, Hi2, Hi2);
		//printf("%x %x %x %x %x %x %x %x \n", Hi2[0], Hi2[1], Hi2[2], Hi2[3], Hi2[4], Hi2[5], Hi2[6], Hi2[7]);


		ichA = 0;
		for (int i = 0; i< 8; i++)
		{
			
			ichA = ichA*(0x100000000);

			ichA = ichA + Hi[i];
			
		}

	////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////

		return (ichA);
	}
};
